@startuml
skin rose
top to bottom direction
skinparam linetype straight

' ==================== MODELS ====================

abstract class Entity {
    # name: String
    + Entity(String)
    + {abstract} getInventory(): Inventory
    + getName(): String
}

abstract class Human extends Entity {
    # inventory: Inventory
    # distractionLevel: float
    # - allHumans: ArrayList<Human> <<static>>
    + Human(String)
    + Human(String, Inventory)
    + {abstract} showInventory(): Event
    + checkWardrobe(): EventSequence
    + wakeUp(Time, ArrayList<Event>): EventSequence
    + wakeUp(Time): EventSequence
    + addToInventory(Item): Event throws InventoryFullException
    + addToInventory(Item, Places): Event throws InventoryFullException
    + rmFromInventory(Item): Event
    + getInventory(): Inventory
    - rememberImportantItemsLost(EventSequence): void
    - checkForSpecificImportantItems(EventSequence): void
    - findAllImportantItems(EventSequence): void
    - findImportantItemsInClothesInventory(Inventory, EventSequence, String): void
    - findImportantItemsInInventory(Inventory, EventSequence, String): void
    - findImportantItemsInInventory(Inventory, EventSequence, String, String): void
    - getCurrentOwnerName(Inventory, Human): String
}

class Shutilo extends Human implements Distractable {
    + Shutilo()
    + veryHurry(): EventSequence
    + jumpOverRoom(): Event
    + goOut(Jacket): Event
    + collideWith(Breakable): Event
    + distract(): Event
    + showInventory(): Event
}

class Korzhik extends Human {
    + Korzhik()
    + showInventory(): Event
}

class Swisstulkin extends Human {
    + Swisstulkin()
    + showInventory(): Event
}

abstract class Item extends Entity {
    # owner: Human
    # important: boolean
    + Item(Human, String)
    + Item(Human, String, boolean)
    + {abstract} changeState(String): Event
    + getOwner(): Human
    + isImportant(): boolean
}

abstract class Cloth extends Item implements Wearable {
    # whoWears: Human
    + Cloth(Human, String)
    + {abstract} wear(): Event throws ClothingMiswearException
    + {abstract} wear(Human): Event throws ClothingMiswearException
    + {abstract} maintainAppearance(): Event
    + {abstract} changeState(String): Event
    + checkWhoWears(): Event
    + getWhoWears(): Human
    + getInventory(): Inventory
}

class Tie extends Cloth implements WearableInsideOut {
    + Tie(Human, String)
    + wear(Human): Event throws ClothingMiswearException
    + wear(): Event throws ClothingMiswearException
    + maintainAppearance(): Event
    + changeState(String): Event
}

class Pants extends Cloth implements Misswearable {
    + Pants(Human, String)
    + wear(Human): Event throws ClothingMiswearException
    + wear(): Event throws ClothingMiswearException
    + maintainAppearance(): Event
    + changeState(String): Event
}

class Chulki extends Cloth implements Missarangeable {
    + Chulki(Human, String)
    + wear(Human): Event throws ClothingMiswearException
    + wear(): Event throws ClothingMiswearException
    + maintainAppearance(): Event
    + changeState(String): Event
}

class Jacket extends Cloth implements Storable {
    - inventory: Inventory
    + Jacket(Human, String)
    + wear(Human): Event throws ClothingMiswearException
    + wear(): Event throws ClothingMiswearException
    + store(Item): void throws Exception
    + maintainAppearance(): Event
    + changeState(String): Event
    + getInventory(): Inventory
}

class Car extends Item {
    + Car(String, Human)
    + changeState(String): Event
}

class DriverLicense extends Item {
    - vehicle: Car
    - isLost: boolean
    + DriverLicense(Car)
    + getVehicle(): Car
    - setVehicle(Car): void
    + isLost(): boolean
    + markAsLost(): void throws ItemLostException
    + changeState(String): Event
    + getInventory(): Inventory <<throws UnsupportedOperationException>>
}

class Flower extends Item {
    + Flower(FlowerType)
    + changeState(String): Event
}

class FlowerPot implements Storable, Breakable {
    - flower: FlowerType
    + FlowerPot(FlowerType)
    + store(Item): void throws Exception
    + breakItem(): Event
    + getFlower(): FlowerType
    + setFlower(FlowerType): void
    + addFlower(FlowerType): void
}

class Inventory implements Storable {
    - inventory: ArrayList<InventoryCell>
    - MAX_CAPACITY: int = 5
    + Inventory()
    + getInventory(): ArrayList<InventoryCell>
    + addItem(Item): void throws InventoryFullException
    + addItem(Item, Places): void throws InventoryFullException
    + rmItem(Item): void
    + store(Item): void throws Exception
    + show(): String
    + isEmpty(): boolean
}

class InventoryCell <<record>> {
    - item: Item
    - place: Places
    + InventoryCell(Item, Places)
    + getItem(): Item
    + place(): Places
}

class Time {
    - h: int
    - m: int
    - s: int
    - duration: String
    + Time()
    + Time(int, int, int)
    + Time(String)
    + getString(): String
    + update(int, int, int): Time
    + elapse(int, int, int): Time
    + getH(): int
    + getM(): int
    + getS(): int
}

class Event {
    - subject: ArrayList<Entity>
    - event: String
    - when: Time
    - object: Entity
    + Event()
    + Event(String)
    + Event(String, ArrayList<Entity>)
    + Event(String, ArrayList<Entity>, Time)
    + Event(String, ArrayList<Entity>, Time, Entity)
    + addSubject(Entity): Event
    + addTime(Time): Event
    + addObject(Entity): Event
    + addCondition(String): Event
    + happen(): String
}

class EventSequence {
    - sequence: ArrayList<Event>
    + EventSequence()
    + EventSequence(ArrayList<Event>)
    + addEvent(Event): EventSequence
    + addCondition(Event): EventSequence
    + addTime(Time): EventSequence
    + simulate(): void
}

class Story {
    - story: ArrayList<EventSequence>
    + Story()
    + tell(): void
    + addSequence(EventSequence): void
}

' ==================== EXCEPTIONS ====================

class ClothingMiswearException extends Exception {
    + ClothingMiswearException(String)
}

class ItemLostException extends Exception {
    + ItemLostException(String, String)
}

class InventoryFullException extends RuntimeException {
    + InventoryFullException(String)
}

' ==================== INTERFACES ====================

interface Wearable {
    + {abstract} wear(): Event throws ClothingMiswearException
    + {abstract} wear(Human): Event throws ClothingMiswearException
    + {abstract} maintainAppearance(): Event
    + {abstract} changeState(String): Event
}

interface WearableInsideOut extends Wearable {
    + {abstract} wearInsideOut(): Event
}

interface Misswearable extends Wearable {
    + {abstract} misswear(): Event throws ClothingMiswearException
}

interface Missarangeable {
    + {abstract} misarrange(): Event throws ClothingMiswearException
}

interface Storable {
    + {abstract} store(Item): void throws Exception
}

interface Breakable {
    + {abstract} breakItem(): Event
}

interface Distractable {
    + {abstract} distract(): Event
}

' ==================== ENUMS ====================

enum Places {
    LEFTPOCKET: "левый карман"
    RIGHTPOCKET: "правый карман"
    DEFAULT: "ячейка инвентаря по умолчанию"
    + getIndex(): int
    + getPlace(): String
}

enum FlowerType {
    DAISY: "маргаритка"
    TULIP: "тюльпан"
    ROSE: "роза"
}

' ==================== RELATIONSHIPS ====================

' Иерархия классов
' Entity <|-- Human
' Entity <|-- Item
' Human <|-- Shutilo
' Human <|-- Korzhik
' Human <|-- Swisstulkin
' Item <|-- Cloth
' Item <|-- Car
' Item <|-- DriverLicense
' Item <|-- Flower
' Cloth <|-- Tie
' Cloth <|-- Pants
' Cloth <|-- Chulki
' Cloth <|-- Jacket

' Главная архитектура: Story → EventSequence → Event
Story "1" *-- "many" EventSequence : содержит
EventSequence "1" *-- "many" Event : содержит
Event --> Time : время
Event "1" --> "0..*" Entity : субъект/объект

' Инвентарь
Human "1" *-- "1" Inventory : имеет
Inventory "1" *-- "0..*" InventoryCell : ячейки
InventoryCell "1" --> "1" Item : предмет
InventoryCell "1" --> "1" Places : расположение
Jacket "1" *-- "1" Inventory : карманы

' Владение предметами
Item "many" --> "1" Human : владелец
Cloth "many" --> "0..1" Human : носит

' Связи между предметами
DriverLicense "1" --> "1" Car : для автомобиля
FlowerPot "1" --> "0..1" FlowerType : цветок
Flower "1" --> "1" FlowerType : тип

' Реализация интерфейсов
' Human ..|> Distractable
' Jacket ..|> Storable
' FlowerPot ..|> Storable
' FlowerPot ..|> Breakable
' Tie ..|> WearableInsideOut
' Pants ..|> Misswearable
' Chulki ..|> Missarangeable

@enduml